\section{Architectural Design and Technical Considerations}
\label{sec:architectural_design}


\subsection{Clang-based Architectural Design for Hylo's C Interoperability Tooling}

To address the challenges outlined above, we propose a Clang-based architectural design for Hylo's C interoperability tooling. This architecture prioritizes fidelity and automation by leveraging the rich semantic information provided by an industrial-strength compiler front-end.

\subsubsection{Parsing Technology: A Clang-Based Approach}

Generating accurate bindings requires a high-fidelity parser for the C language. While various tools exist, a comparative analysis reveals that leveraging the Clang compiler front-end is the most robust approach. Compilers like GCC offer introspection capabilities through plugins or intermediate representations, but these are often less stable or comprehensive than Clang's libraries. Microsoft's MSVC compiler has historically offered limited public APIs for AST introspection.
Clang, by contrast, provides stable C and C++ libraries (LibClang, LibTooling) designed for building tools that require deep semantic understanding of C-family languages. By using a Clang-based parser, the Hylo interoperability tool can:

\begin{itemize}
    \item Accurately parse a wide range of C dialects and compiler-specific extensions by configuring the Clang front-end with the same flags used to compile the target library.
    \item Gain access to a complete and accurate Abstract Syntax Tree (AST), including type information, source locations, and macro expansions.
\end{itemize}

\textit{TODO: describe various options for parsing C headers, including the comparison for MSVC, GCC, Clang's capabilities regarding AST introspection, C++26 static reflection and macro and template based meta programming based solutions. Spoiler: Clang is the best option, which supports various dialects (including some MSVC and GCC extensions), supports parsing various C standard versions, and can be configured with the exact compiler flags when parsing that they use for compilation. Compare various Clang library versions, including LibClang, Clang plugins, LibTooling and embedding the whole Clang compiler itself.
}

\subsubsection{Architecture of Customizabile Mappings}
TODO compare comment-based vs attribute based mappings, and describe rule files

TODO move this to the relevant section

\subsubsection{FFI Generation vs Direct AST Emission}
TODO add nice diagram of the two types of architectures


\subsubsection{Declarations vs Opaque data + computed properties}
This is important, as unions, bit-fields and other C layout constructs that don't have Hylo representations can be represented as opaque data with computed properties accessing them just like other regular Hylo types. (todo describe problems of separate declarations vs computed properties)

TODO shouldn't be here because it's discussed in the next section in detail.

\subsubsection{Lowering Function Calls and Handling the ABI}

Reimplementing the complex ABI logic for every supported platform is a monumental and error-prone task. Instead, our proposed architecture leverages Clang's own ABI handling capabilities. Since Hylo uses LLVM as its backend, and Clang is also an LLVM-based compiler, we can delegate the responsibility of ABI-correct function lowering to Clang. The interoperability tool can instruct Clang to generate the LLVM Intermediate Representation (IR) for a call to a C function, ensuring that all platform-specific calling conventions and data layout rules are correctly applied. This approach significantly reduces implementation complexity and ensures correctness by relying on the same battle-tested ABI logic used by Clang itself.

TODO discuss what responsibilities are there to correctly call functions and lay out structures according to the platform ABI

todo: describe what are the inherent things that need to be different in ABIs based on different architectures, and what are imposed by the OS and the C language. Mention the problem of compilers incorrectly implementing ABIs which sometimes necessitates the interop tool to implement workarounds for specific compilers or platforms (link Emilio interview).

\subsubsection{Handling Challenging C Constructs}


\subsubsection{IDE Integration}

A seamless developer experience requires that IDE features like code completion, go-to-definition, and renaming work across the C/Hylo boundary. Our design proposes the creation of a Hylo Language Server that acts as a proxy, coordinating with `clangd`, the official C/C++ language server for the LLVM project. When a request is made for a symbol defined in C, the Hylo LSP would forward the request to `clangd` and translate the response. This architecture, inspired by Swift's SourceKit-LSP, allows Hylo to benefit from the full power of `clangd` without having to reimplement its functionality.

TODO include nice diagram, illustrate how symbol renaming works as an example, and check if modifications are needed in clangd or it can be used as is.

