\section{Desirable Properties of a High-Fidelity C Interoperability Layer}
\label{sec:desirable_properties}
TODO introduce this section

\subsection{Automation}
TODO - manual ffi writing is error-prone; try avoiding inconsistencies, detect errors early and provide as much automation as possible.

\subsection{Portability}
TODO

\subsection{High Coverage of C Constructs}
TODO

\subsection{Handling Various C Dialects}

The C language has evolved into various dialects over the course of its 50+ year evolution, despite being specified by an ISO standard. For example, the Linux kernel extensively uses extensions provided by the gcc compiler, thus cannot be compiled with MSVC. Dialects pose a challenge for interoperability, as an interoperability tool shall support a diverse range of C projects to be useful for adopting much of the existing ecosystem.

The primary sources of language differences are as follows:
\begin{itemize}
    \item \textbf{Standard versions:} The C standard has evolved over time, and different projects support different standard versions. Since C is largely backwards compatible, some libraries may stay with older standard to keep supporting their clients who may not be able to upgrade to the latest standard, though they are generally usable from newer language versions.
    \item \textbf{Compiler-specific extensions:} Major compilers like GCC, Clang and MSVC provide various extensions to the language that are not part of the standard. Some extensions only affect implementation like the embedded assembly blocks, while others affect the ABI of the generated code like the \verb|__attribute((packed))__| which can change the memory layout of structs. When implementation is separately maintained outside of header files, only the ABI-affecting category poses challenges, but inline functions are often defined in headers for potential performance benefits, so an interoperability tool shall ideally handle both cases, at least for code parsing but potentially also for code generation (see \autoref{sec:handling_inline_c_functions}).
    \item \textbf{Compiler Plugins:} Clang, GCC - todo describe that they will be out of scope for interop and the reasoning
    \item \textbf{High-performance computing / GPU programming compilers:} NVidia HPC, Intel oneAPI DPC++ - todo research more
    \item \textbf{Conditional Features:} Some features in the C standard are conditionally supported, the compiler vendor doesn't have to support them to be standard compliant. Such features include the \verb|_Atomic| qualifier and complex numbers. The interop tool shall be able to parse all these features.
\end{itemize}

\subsection{Control and Customizability}
There is in fact one more kind of dialect: the semantic meaning of standard C code itself. Unlike C++, C doesn't provide many features for type based abstraction: In C, error conditions are often signaled using special return values (like negative numbers or null pointers) or by setting a global variable. Additionally, C enums frequently serve as bit flags, where individual constants are powers of two, allowing values to represent combinations of these flags. Mapping this lose semantics to stronger types requires additional guidance from the user to avoid ambiguity.

