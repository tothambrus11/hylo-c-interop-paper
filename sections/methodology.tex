\section{Methodology}
This research was conducted using a combination of academic and industry research, expert interviews, implementing prototypes, and feedback from the Hylo developer community. The goal was to gain a deep understanding on the state of the art in C interoperability technologies, and to develop targeted prototypes that demonstrate the feasibility of solving key challenges. 

\subsection{Industry Research}
We started by reviewing the existing C/C++\footnote{C++ was included in this industry research, TODO} interoperability technologies in various programming languages, including Swift, Rust, D, Carbon, and Zenon. This involved reading documentation, blog posts, and watching conference talks to understand their features, limitations, and collect desirable properties for an interoperability solution for Hylo.

We also conducted interviews with language experts from the C++, Rust, Zenon and Hylo language communities. These interviews were conducted in an open format, allowing us to explore specific topics in depth while also gathering general insights on the challenges and solutions related to C (and C++) interoperability. We conducted preliminary discussions within the Hylo community, and gathered feedback on proposed solutions.

\subsection{Academic Literature Review}
We conducted an exploratory academic literature review using a combination of Scopus queries, snowballing from (todo ref), and AI-assisted tools like Elicit and Undermind. The exact prompts are presented in TODO appendix.

The Scopus based search was done in 3 parts: general papers related to cross-language interoperability, papers related to C interoperability, and papers related to C++ interoperability. The search was limited to the last 10 years, as the industry review suggested that most of the significant advancements in high-fidelity interoperability have been made since the introduction of Swift and Rust since 2014 and 2015 respectively. However, snowballing revealed some relevant papers from earlier years, notably (Why IDLs are Not Ideal - todo ref).

\subsection{Prototyping}
There were two POC prototypes implemented during the research: C integer conversions, and FFI code generation using LibClang. For integer conversions, the aim was to design and develop a solution that can be upstreamed to the Hylo compiler and standard library, while the FFI code generator was used to explore the capabilities and limitations of LibClang, as well as familiarizing with Swift's interoperability with C APIs.

The C integer conversions involved API design, implementing the standard library types using code generation for generating the $N^2$ conversions between different sized integers, extending compiler intrinsics, and implementing LLVM lowering for the conversions in the backend. The implementation is available in (todo ref).

The FFI code generator was implemented as a separate tool in Swift, using the LibClang as a C library. Using Swift allowed us to create some safer and simpler abstractions over the C API, such as the ability to print enum values as strings, and get a feel for a seamless editor experience with cross-language navigation, symbol renaming and debugging thanks to SourceKit-LSP.
